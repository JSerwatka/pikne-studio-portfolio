---
import { Image } from "astro:assets";
import heart from "@assets/heart.svg";
// TODO use better names for observer
// TODO sometimes when you scroll fast - the heart is not positioned on the last circle stop - interesection nie zdążyło się wytriggerować
---

<div
    data-gradient-scroll-wrapper
    class:list={["process-grid__line", "relative h-full w-6 border border-ruby-red bg-gradient-brand"]}
>
    <div data-progress-mask class="absolute bottom-0 left-0 w-full bg-light-pink"></div>
    <Image
        data-gradient-scroll-heart
        class="absolute left-1/2 z-20 max-w-none -translate-x-1/2 -translate-y-1/2"
        src={heart}
        alt="heart symbol"
        width="50"
        height="50"
    />
</div>
{
    Array(7)
        .fill(0)
        .map((_, index) => (
            <div
                data-circle-stop={index}
                style={"--start-row: " + (index * 4 + 1)}
                class:list={[
                    "process-grid__circle",
                    "z-10 h-10 w-10 rounded-full border border-ruby-red bg-light-pink"
                ]}
            />
        ))
}

<style>
    .process-grid__circle {
        grid-column: 1 / 2;
        grid-row: var(--start-row) / span 2;
        align-self: center;
        justify-self: center;
    }

    .process-grid__line {
        grid-column: 1 / 2;
        grid-row: 2 / -4;
        justify-self: center;
    }

    [data-progress-mask] {
        height: var(--height, 100%);
        transition: height 0.7s ease-out;
    }

    [data-gradient-scroll-heart] {
        top: var(--top, 0px);
        transition: top 0.7s ease-out;
    }
</style>

<script>
    const gradientScrollWrapper = document.querySelector("[data-gradient-scroll-wrapper]") as HTMLElement;
    const gradientScrollHeart = document.querySelector("[data-gradient-scroll-heart]") as HTMLElement;
    const progressMask = document.querySelector("[data-progress-mask]") as HTMLElement;
    const circleStops = document.querySelectorAll("[data-circle-stop]") as NodeListOf<HTMLElement>;
    let currentStopIndex = 0;

    function updateHeartPosition(currentStopIndex: number) {
        // relative to gradientScrollWrapper
        const nextCircleStopPostion =
            circleStops[currentStopIndex].offsetTop +
            circleStops[currentStopIndex].offsetHeight / 2 -
            gradientScrollWrapper.offsetTop;

        const progress = nextCircleStopPostion / gradientScrollWrapper.offsetHeight;

        progressMask.style.setProperty("--height", `${(1 - progress) * 100}%`);
        gradientScrollHeart.style.setProperty("--top", nextCircleStopPostion.toString() + "px");
    }

    const options = {
        rootMargin: "-50% 0px -50% 0px"
    };
    const observer = new IntersectionObserver((entries, observer) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                currentStopIndex = Number((entry.target as HTMLElement).dataset.circleStop ?? "0");

                updateHeartPosition(currentStopIndex);
            }
        });
    }, options);

    circleStops.forEach((circleStop) => observer.observe(circleStop));

    window.addEventListener("resize", () => {
        updateHeartPosition(currentStopIndex);
    });
</script>
