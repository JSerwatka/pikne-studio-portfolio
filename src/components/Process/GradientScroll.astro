---
import { Image } from "astro:assets";
import heart from "@assets/heart.svg";
// translate-y-1 h-[88%] styles that correctly position gradient scroll
// TODO make sure that heart is position correctly on start (before scrolling)
---

<div data-gradient-scroll-wrapper class="relative h-full w-6 border border-ruby-red bg-gradient-brand">
    <div data-progress-mask class="absolute bottom-0 left-0 w-full bg-light-pink"></div>
    <Image
        data-gradient-scroll-heart
        class="absolute z-20 max-w-none -translate-x-[50%]"
        src={heart}
        alt="heart symbol"
        width="50"
        height="50"
    />
    <div class="grid h-full grid-rows-7 justify-center">
        {
            Array(7)
                .fill(0)
                .map((_, index) => (
                    <div
                        data-circle-stop={index}
                        class:list={[
                            "z-10 col-span-1 col-start-1 row-span-1 h-10 w-10 justify-self-center rounded-full border border-ruby-red bg-light-pink",
                            `row-start-${index + 1}`
                        ]}
                    />
                ))
        }
    </div>
</div>

<style>
    [data-progress-mask] {
        height: var(--height, "100%");
        transition: height 0.7s ease-out;
    }

    [data-gradient-scroll-heart] {
        top: var(--top, "0px");
        left: var(--left, "0px");
        transition: top 0.5s linear;
    }
</style>

<script>
    import { scroll, animate, inView } from "motion";
    import { getAbsoluteBoundingClientReact } from "@utils/domHelpers";

    const gradientScrollWrapper = document.querySelector("[data-gradient-scroll-wrapper]") as HTMLElement;
    const gradientScrollHeart = document.querySelector("[data-gradient-scroll-heart]") as HTMLElement;
    const progressMask = document.querySelector("[data-progress-mask]") as HTMLElement;
    const circleStops = document.querySelectorAll("[data-circle-stop]") as NodeListOf<HTMLElement>;
    let currentStopIndex = 0;

    const gradientScrollWrapperRect = getAbsoluteBoundingClientReact(gradientScrollWrapper);

    function updateHeartPosition(currentStopIndex: number) {
        const nextCircleStopRect = getAbsoluteBoundingClientReact(circleStops[currentStopIndex]);

        const newHeartPosition = {
            top: nextCircleStopRect.top - gradientScrollWrapperRect.top,
            left: nextCircleStopRect.left - gradientScrollWrapperRect.left + nextCircleStopRect.width / 2
        };

        gradientScrollHeart.style.setProperty("--top", newHeartPosition.top.toString() + "px");
        gradientScrollHeart.style.setProperty("--left", newHeartPosition.left.toString() + "px");
    }

    // function getProgress(currentStopIndex: number) {
    //     const nextCircleStopRect = getAbsoluteBoundingClientReact(circleStops[currentStopIndex]);
    //     return (nextCircleStopRect.top - gradientScrollWrapperRect.top) / gradientScrollWrapperRect.height;
    // }

    // function updateCircleStopStyles(currentStopIndex: number) {
    //     const circleStopElement = circleStops[currentStopIndex];
    //     circleStopElement.classList.toggle("bg-ruby-red", visited);
    // }

    circleStops.forEach((circleStop) => {
        inView(
            circleStop,
            (enterTargetInfo) => {
                // TODO better handle undefined
                const enterTargetIndex = Number((enterTargetInfo.target as HTMLElement).dataset.circleStop ?? "0");

                if (enterTargetIndex > currentStopIndex) {
                    currentStopIndex = enterTargetIndex;
                    updateHeartPosition(currentStopIndex);
                    // console.log(getProgress(currentStopIndex));
                    // updateCircleStopStyles(currentStopIndex);
                }

                return (leaveTargetInfo) => {
                    // TODO better handle undefined
                    const leaveTargetIndex = Number((leaveTargetInfo.target as HTMLElement).dataset.circleStop ?? "0");

                    if (leaveTargetIndex !== currentStopIndex) return;

                    if (currentStopIndex <= 0) {
                        currentStopIndex = 0;
                    } else {
                        currentStopIndex -= 1;
                    }

                    updateHeartPosition(currentStopIndex);
                    // updateCircleStopStyles(currentStopIndex);
                };
            },
            { margin: "0px 0px 0px 0px" }
        );
    });

    // window.addEventListener("scroll", () => console.log(getElementPosition(circleStops[3])));

    // scroll(
    //     ({ y }) => {
    //         const middleOfHeartHeight = gradientScrollImage.clientHeight / 2;
    //         const middleOfHeartWidth = gradientScrollImage.clientWidth / 2;

    //         const progressToPxMapped = y.progress * (gradientScrollWrapper.clientHeight - middleOfHeartHeight);

    //         // height has to be inversely proportional to scroll progess - we are changing mask height
    //         progressMask.style.setProperty("--height", `${(1 - y.progress) * 100}%`);

    //         animate(
    //             gradientScrollImage,
    //             { transform: [`translate(-${middleOfHeartWidth}%, ${progressToPxMapped}px)`] },
    //             { duration: 0.7, easing: "ease-out" }
    //         );
    //     },
    //     { target: gradientScrollWrapper, offset: ["-150px start", "end center"] }
    // );
</script>
