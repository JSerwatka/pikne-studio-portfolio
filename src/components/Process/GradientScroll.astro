---
import { Image } from "astro:assets";
import heart from "@assets/heart.svg";
// translate-y-1 h-[88%] styles that correctly position gradient scroll
// TODO make sure that heart is position correctly on start (before scrolling)
---

<div
    data-gradient-scroll-wrapper
    class:list={["process-grid__line", "relative h-full w-6 border border-ruby-red bg-gradient-brand"]}
>
    <div data-progress-mask class="absolute bottom-0 left-0 w-full bg-light-pink"></div>
    <Image
        data-gradient-scroll-heart
        class="absolute left-1/2 z-20 max-w-none -translate-x-1/2 -translate-y-1/2"
        src={heart}
        alt="heart symbol"
        width="50"
        height="50"
    />
</div>
{
    Array(7)
        .fill(0)
        .map((_, index) => (
            <div
                data-circle-stop={index}
                style={"--start-row: " + (index * 4 + 1)}
                class:list={[
                    "process-grid__circle",
                    "z-10 h-10 w-10 rounded-full border border-ruby-red bg-light-pink"
                ]}
            />
        ))
}

<style>
    .process-grid__circle {
        grid-column: 1 / 2;
        grid-row: var(--start-row) / span 2;
        align-self: center;
        justify-self: center;
    }

    .process-grid__line {
        grid-column: 1 / 2;
        grid-row: 2 / -4;
        justify-self: center;
    }

    [data-progress-mask] {
        height: var(--height, "100%");
        transition: height 0.7s ease-out;
    }

    /* [data-gradient-scroll-heart] {
        top: var(--top, "0px");
        left: var(--left, "0px");
        transition: top 0.5s linear;
    } */
</style>

<!-- <script>
    import { scroll, animate, inView } from "motion";
    import { getAbsoluteBoundingClientReact } from "@utils/domHelpers";

    const gradientScrollWrapper = document.querySelector("[data-gradient-scroll-wrapper]") as HTMLElement;
    const gradientScrollHeart = document.querySelector("[data-gradient-scroll-heart]") as HTMLElement;
    const progressMask = document.querySelector("[data-progress-mask]") as HTMLElement;
    const circleStops = document.querySelectorAll("[data-circle-stop]") as NodeListOf<HTMLElement>;
    let currentStopIndex = 0;

    const gradientScrollWrapperRect = getAbsoluteBoundingClientReact(gradientScrollWrapper);

    function updateHeartPosition(currentStopIndex: number) {
        const nextCircleStopRect = getAbsoluteBoundingClientReact(circleStops[currentStopIndex]);

        const newHeartPosition = {
            top: nextCircleStopRect.top - gradientScrollWrapperRect.top,
            left: nextCircleStopRect.left - gradientScrollWrapperRect.left + nextCircleStopRect.width / 2
        };

        gradientScrollHeart.style.setProperty("--top", newHeartPosition.top.toString() + "px");
        gradientScrollHeart.style.setProperty("--left", newHeartPosition.left.toString() + "px");
    }

    // function getProgress(currentStopIndex: number) {
    //     const nextCircleStopRect = getAbsoluteBoundingClientReact(circleStops[currentStopIndex]);
    //     return (nextCircleStopRect.top - gradientScrollWrapperRect.top) / gradientScrollWrapperRect.height;
    // }

    // function updateCircleStopStyles(currentStopIndex: number) {
    //     const circleStopElement = circleStops[currentStopIndex];
    //     circleStopElement.classList.toggle("bg-ruby-red", visited);
    // }

    circleStops.forEach((circleStop) => {
        inView(
            circleStop,
            (enterTargetInfo) => {
                // TODO better handle undefined
                const enterTargetIndex = Number((enterTargetInfo.target as HTMLElement).dataset.circleStop ?? "0");

                if (enterTargetIndex > currentStopIndex) {
                    currentStopIndex = enterTargetIndex;
                    updateHeartPosition(currentStopIndex);
                    // console.log(getProgress(currentStopIndex));
                    // updateCircleStopStyles(currentStopIndex);
                }

                return (leaveTargetInfo) => {
                    // TODO better handle undefined
                    const leaveTargetIndex = Number((leaveTargetInfo.target as HTMLElement).dataset.circleStop ?? "0");

                    if (leaveTargetIndex !== currentStopIndex) return;

                    if (currentStopIndex <= 0) {
                        currentStopIndex = 0;
                    } else {
                        currentStopIndex -= 1;
                    }

                    updateHeartPosition(currentStopIndex);
                    // updateCircleStopStyles(currentStopIndex);
                };
            },
            { margin: "0px 0px 0px 0px" }
        );
    });

    // window.addEventListener("scroll", () => console.log(getElementPosition(circleStops[3])));

    scroll(
        ({ y }) => {
            const middleOfHeartHeight = gradientScrollHeart.clientHeight / 2;
            const middleOfHeartWidth = gradientScrollHeart.clientWidth / 2;

            const progressToPxMapped = y.progress * (gradientScrollWrapper.clientHeight - middleOfHeartHeight);
            console.log(y.progress);
            // height has to be inversely proportional to scroll progess - we are changing mask height
            progressMask.style.setProperty("--height", `${(1 - y.progress) * 100}%`);

            // animate(
            //     gradientScrollImage,
            //     { transform: [`translate(-${middleOfHeartWidth}%, ${progressToPxMapped}px)`] },
            //     { duration: 0.7, easing: "ease-out" }
            // );
            // TODO instead of 150px use grid height
        },
        { target: gradientScrollWrapper, offset: ["-150px start", "end center"] }
    );
</script> -->
