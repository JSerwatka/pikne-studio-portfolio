---
import Navbar from "@components/Navbar/Navbar.astro";
import ScrollIndicator from "@components/ScrollIndicator.astro";
---

<div data-title-container class="relative h-svh overflow-hidden uppercase">
    <div data-blob>
        <svg viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <clipPath id="a">
                    <path
                        fill="currentColor"
                        d="M826 608q-69 108-161.5 203T421 902.5Q270 899 257 746t-85-272.5q-72-119.5 33-211T443 121q133-50 268.5 19T871 354.5Q895 500 826 608Z"
                    ></path>
                </clipPath>
                <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:aquamarine;stop-opacity:0.6"></stop>
                    <stop offset="100%" style="stop-color:mediumpurple;stop-opacity:0.6"></stop>
                </linearGradient>
            </defs>
            <g clip-path="url(#a)">
                <path
                    fill="url(#gradient)"
                    d="M826 608q-69 108-161.5 203T421 902.5Q270 899 257 746t-85-272.5q-72-119.5 33-211T443 121q133-50 268.5 19T871 354.5Q895 500 826 608Z"
                ></path>
            </g>
        </svg>
    </div>
    <div data-blur></div>
    <div class="relative z-10 flex h-full flex-col">
        <Navbar />
        <div class="flex flex-grow flex-col justify-center text-center">
            <div class="text-paragraph__normal">At Pikne we are good at</div>
            <div class="mt-5 font-olympic text-[clamp(50px,5vw,125px)] leading-[1.1em]">
                translating <span class="normal-case">feelings</span>
                <span class="block">to visuals</span>
            </div>
            <div class="text-paragraph__normal">FOR BRANDS & CAMPAIGNS</div>
        </div>
        <ScrollIndicator />
    </div>
</div>

<style>
    @keyframes rotate {
        from {
            rotate: 0deg;
        }
        to {
            rotate: 360deg;
        }
    }
    [data-blob] {
        height: 80vmax;
        aspect-ratio: 1;
        position: absolute;
        left: 50%;
        top: 50%;
        translate: -50% -50%;
        animation: rotate 25s infinite;
        opacity: 0.7;
    }

    [data-blur] {
        height: 100%;
        width: 100%;
        position: absolute;
        z-index: 2;
        backdrop-filter: blur(4vmax);
    }
</style>

<script>
    const blob = document.querySelector("[data-blob]") as HTMLElement;
    const container = document.querySelector("[data-title-container]") as HTMLElement;

    const percentagesOfWiderScreen = [0.25, 0.5, 0.75];
    const percentagesOfNarrowerScreen = [0.3, 0.6];
    const idleAnimationFrequency = 8000;
    const idleAnimationResponse = 1000;
    const mouseAnimationDuration = 30000;

    let timerId: number | undefined;
    let intervalId: number | undefined;
    let lastTargetX: null | number = null;
    let lastTargetY: null | number = null;

    function moveBlobToMouse(event: PointerEvent) {
        const { clientX, clientY } = event;
        animateBlob(clientX, clientY, mouseAnimationDuration);
    }

    function moveBlobInIdleState() {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        let targetX, targetY;

        const isWideScreen = viewportWidth > viewportHeight;
        const xPercantageTable = isWideScreen ? percentagesOfWiderScreen : percentagesOfNarrowerScreen;
        const yPercantageTable = isWideScreen ? percentagesOfNarrowerScreen : percentagesOfWiderScreen;

        do {
            const randomXPercentage = xPercantageTable[Math.floor(Math.random() * xPercantageTable.length)];
            const randomYPercentage = yPercantageTable[Math.floor(Math.random() * yPercantageTable.length)];
            targetX = randomXPercentage * viewportWidth;
            targetY = randomYPercentage * viewportHeight;
        } while (targetX === lastTargetX && targetY === lastTargetY);

        animateBlob(targetX, targetY, idleAnimationFrequency);
        lastTargetX = targetX;
        lastTargetY = targetY;
    }
    let animateEl: Animation | null;
    function animateBlob(positionX: number, positionY: number, animationDuration: number) {
        animateEl = blob.animate(
            {
                left: `${positionX}px`,
                top: `${positionY}px`
            },
            {
                duration: animationDuration,
                fill: "forwards",
                easing: "ease-in-out"
            }
        );
    }

    function handleIdle(idleResponse = idleAnimationResponse) {
        clearTimeout(timerId);
        clearInterval(intervalId);
        timerId = setTimeout(() => {
            moveBlobInIdleState();
            intervalId = setInterval(moveBlobInIdleState, idleAnimationFrequency);
        }, idleResponse);
    }

    container.addEventListener("pointermove", (event: PointerEvent) => {
        handleIdle();
        moveBlobToMouse(event);
    });

    handleIdle(0);
</script>
