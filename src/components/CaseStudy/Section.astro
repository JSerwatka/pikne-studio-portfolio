---
import Stepper from "./Stepper.astro";

interface Props {
    class?: string;
    step: number;
}

const { class: className, step } = Astro.props;
// TODO: adjust img sizes on screens
---

<div data-scroll-animation-container class:list={["h-screen text-dark-chocolate", className]}>
    <div class:list={["grid h-full grid-cols-12 grid-rows-2", "gap-y-4", "lg:grid-rows-none lg:gap-y-0"]}>
        <div
            class:list={[
                "col-span-12 row-span-1 row-start-2",
                "lg:col-span-6 lg:col-start-2 lg:row-span-1 lg:row-start-1 lg:self-center"
            ]}
        >
            <div class="text-header__2">
                <slot name="title" />
            </div>
            <div class="text-paragraph__normal">
                <slot name="description" />
            </div>
        </div>
        <div
            data-imgs-container
            class:list={[
                "relative h-[300px] w-[300px] self-center justify-self-center [&>*]:absolute",
                "col-span-9 col-start-3 row-span-1 row-start-1",
                "lg:col-span-5 lg:col-start-8 lg:row-span-1 lg:row-start-1"
            ]}
        >
            <slot name="images" />
        </div>
        <div
            class:list={[
                "self-center",
                "col-span-3 col-start-1 row-span-1 row-start-1",
                "lg:col-span-2 lg:col-start-1"
            ]}
        >
            <Stepper step={step} class="[&>circle]:stroke-dark-chocolate" />
        </div>
    </div>
</div>

<script>
    import { scroll, timeline, type TimelineDefinition } from "motion";
    import type { TranslationPathType, RotationPathType } from "@components/CaseStudy/AnimatedImage.astro";
    import { zip } from "@utils/zip";

    const animationContainers = document.querySelectorAll(
        "[data-scroll-animation-container]"
    ) as NodeListOf<HTMLElement>;

    // animate all sections' imgs on scroll by animation path
    animationContainers.forEach((animationContainer) => {
        const imageAnimationContainers = Array.from(
            animationContainer.querySelectorAll(
                "[data-translation-path],[data-rotation-path]"
            ) as NodeListOf<HTMLElement>
        );

        const sequence = imageAnimationContainers.map((imageAnimationContainer) => {
            const translationPath = JSON.parse(
                imageAnimationContainer.dataset.translationPath ?? "[]"
            ) as TranslationPathType;

            const rotationPath = JSON.parse(imageAnimationContainer.dataset.rotationPath ?? "[]") as RotationPathType;

            const aimationsMapped = zip(
                translationPath,
                rotationPath,
                (translationElement, rotationElement): string => {
                    const translationString = translationElement
                        ? `translate(${translationElement[0]}%, ${translationElement[1]}%)`
                        : "";
                    const rotationString = rotationElement !== undefined ? `rotate(${rotationElement}deg)` : "";

                    return [translationString, rotationString].filter(Boolean).join(",");
                }
            );

            return [imageAnimationContainer, { transform: ["translate(0, 0)", ...aimationsMapped] }, { at: "<" }];
        }) satisfies TimelineDefinition;

        const options = {
            defaultOptions: { ease: "ease" }
        };

        scroll(timeline(sequence, options), { target: animationContainer, offset: ["25% end", "end end"] });
    });
</script>
